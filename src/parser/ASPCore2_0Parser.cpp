/** \file
 *  This C++ source file was generated by $ANTLR version 3.5
 *
 *     -  From the grammar source file : ./ASPCore2_0.g
 *     -                            On : 2013-07-15 18:46:23
 *     -                for the parser : ASPCore2_0ParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "ASPCore2_0Parser.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

	namespace 	User  {

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   ASPCore2_0ParserTokenNames[12+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "ID",
        (ANTLR_UINT8*) "INT",
        (ANTLR_UINT8*) "WS",
        (ANTLR_UINT8*) "'('",
        (ANTLR_UINT8*) "')'",
        (ANTLR_UINT8*) "'*'",
        (ANTLR_UINT8*) "'+'",
        (ANTLR_UINT8*) "';'",
        (ANTLR_UINT8*) "'='",
        (ANTLR_UINT8*) "'method'",
        (ANTLR_UINT8*) "'{'",
        (ANTLR_UINT8*) "'}'"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "./ASPCore2_0.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* ASPCore2_0Parser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new ASPCore2_0Parser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ASPCore2_0Parser::ASPCore2_0Parser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new ASPCore2_0Parser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ASPCore2_0Parser::ASPCore2_0Parser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void ASPCore2_0Parser::init(StreamType* instream)
{
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( ASPCore2_0ParserTokenNames );


}

void
ASPCore2_0Parser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
ASPCore2_0Parser::~ASPCore2_0Parser()
 {
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return ASPCore2_0ParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: ASPCore2_0Parser  */
static	ANTLR_BITWORD FOLLOW_method_in_program66_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  ASPCore2_0ParserImplTraits::BitsetListType FOLLOW_method_in_program66( FOLLOW_method_in_program66_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: ASPCore2_0Parser  */
static	ANTLR_BITWORD FOLLOW_13_in_method95_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000010) };
static  ASPCore2_0ParserImplTraits::BitsetListType FOLLOW_13_in_method95( FOLLOW_13_in_method95_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: ASPCore2_0Parser  */
static	ANTLR_BITWORD FOLLOW_ID_in_method97_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  ASPCore2_0ParserImplTraits::BitsetListType FOLLOW_ID_in_method97( FOLLOW_ID_in_method97_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: ASPCore2_0Parser  */
static	ANTLR_BITWORD FOLLOW_7_in_method99_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000100) };
static  ASPCore2_0ParserImplTraits::BitsetListType FOLLOW_7_in_method99( FOLLOW_7_in_method99_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: ASPCore2_0Parser  */
static	ANTLR_BITWORD FOLLOW_8_in_method101_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  ASPCore2_0ParserImplTraits::BitsetListType FOLLOW_8_in_method101( FOLLOW_8_in_method101_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: ASPCore2_0Parser  */
static	ANTLR_BITWORD FOLLOW_body_in_method105_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  ASPCore2_0ParserImplTraits::BitsetListType FOLLOW_body_in_method105( FOLLOW_body_in_method105_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: ASPCore2_0Parser  */
static	ANTLR_BITWORD FOLLOW_14_in_body125_bits[]	= { ANTLR_UINT64_LIT(0x000000000000A010) };
static  ASPCore2_0ParserImplTraits::BitsetListType FOLLOW_14_in_body125( FOLLOW_14_in_body125_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: ASPCore2_0Parser  */
static	ANTLR_BITWORD FOLLOW_bstat_in_body127_bits[]	= { ANTLR_UINT64_LIT(0x000000000000A010) };
static  ASPCore2_0ParserImplTraits::BitsetListType FOLLOW_bstat_in_body127( FOLLOW_bstat_in_body127_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: ASPCore2_0Parser  */
static	ANTLR_BITWORD FOLLOW_15_in_body130_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  ASPCore2_0ParserImplTraits::BitsetListType FOLLOW_15_in_body130( FOLLOW_15_in_body130_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: ASPCore2_0Parser  */
static	ANTLR_BITWORD FOLLOW_ID_in_bstat151_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  ASPCore2_0ParserImplTraits::BitsetListType FOLLOW_ID_in_bstat151( FOLLOW_ID_in_bstat151_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: ASPCore2_0Parser  */
static	ANTLR_BITWORD FOLLOW_12_in_bstat153_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000030) };
static  ASPCore2_0ParserImplTraits::BitsetListType FOLLOW_12_in_bstat153( FOLLOW_12_in_bstat153_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: ASPCore2_0Parser  */
static	ANTLR_BITWORD FOLLOW_expr_in_bstat155_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  ASPCore2_0ParserImplTraits::BitsetListType FOLLOW_expr_in_bstat155( FOLLOW_expr_in_bstat155_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: ASPCore2_0Parser  */
static	ANTLR_BITWORD FOLLOW_11_in_bstat157_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  ASPCore2_0ParserImplTraits::BitsetListType FOLLOW_11_in_bstat157( FOLLOW_11_in_bstat157_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: ASPCore2_0Parser  */
static	ANTLR_BITWORD FOLLOW_method_in_bstat167_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  ASPCore2_0ParserImplTraits::BitsetListType FOLLOW_method_in_bstat167( FOLLOW_method_in_bstat167_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: ASPCore2_0Parser  */
static	ANTLR_BITWORD FOLLOW_mul_in_expr182_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000402) };
static  ASPCore2_0ParserImplTraits::BitsetListType FOLLOW_mul_in_expr182( FOLLOW_mul_in_expr182_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: ASPCore2_0Parser  */
static	ANTLR_BITWORD FOLLOW_10_in_expr185_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000030) };
static  ASPCore2_0ParserImplTraits::BitsetListType FOLLOW_10_in_expr185( FOLLOW_10_in_expr185_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: ASPCore2_0Parser  */
static	ANTLR_BITWORD FOLLOW_mul_in_expr187_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000402) };
static  ASPCore2_0ParserImplTraits::BitsetListType FOLLOW_mul_in_expr187( FOLLOW_mul_in_expr187_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: ASPCore2_0Parser  */
static	ANTLR_BITWORD FOLLOW_atom_in_mul205_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000202) };
static  ASPCore2_0ParserImplTraits::BitsetListType FOLLOW_atom_in_mul205( FOLLOW_atom_in_mul205_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: ASPCore2_0Parser  */
static	ANTLR_BITWORD FOLLOW_9_in_mul208_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000030) };
static  ASPCore2_0ParserImplTraits::BitsetListType FOLLOW_9_in_mul208( FOLLOW_9_in_mul208_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: ASPCore2_0Parser  */
static	ANTLR_BITWORD FOLLOW_atom_in_mul210_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000202) };
static  ASPCore2_0ParserImplTraits::BitsetListType FOLLOW_atom_in_mul210( FOLLOW_atom_in_mul210_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start program
 * ./ASPCore2_0.g:42:1: program : method ;
 */
void
ASPCore2_0Parser::program()
{
        ASPCore2_0ParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // ./ASPCore2_0.g:43:5: ( method )
        // ./ASPCore2_0.g:43:7: method
        {
            this->followPush(FOLLOW_method_in_program66);
            method();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprogramEx;
            }


            {
                std::cout<< "maio";
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprogramEx; /* Prevent compiler warnings */
    ruleprogramEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end program */

/**
 * $ANTLR start method
 * ./ASPCore2_0.g:45:1: method : 'method' ID '(' ')' body ;
 */
void
ASPCore2_0Parser::method()
{
        ASPCore2_0ParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    const CommonTokenType*    ID1;

    /* Initialize rule variables
     */
    m_method_stack.push(methodScope()); 
    ID1       = NULL;


 
    {
        // ./ASPCore2_0.g:57:5: ( 'method' ID '(' ')' body )
        // ./ASPCore2_0.g:57:9: 'method' ID '(' ')' body
        {
             this->matchToken(13, &FOLLOW_13_in_method95);
            if  (this->hasException())
            {
                goto rulemethodEx;
            }


            ID1 =  this->matchToken(ID, &FOLLOW_ID_in_method97);
            if  (this->hasException())
            {
                goto rulemethodEx;
            }


             this->matchToken(7, &FOLLOW_7_in_method99);
            if  (this->hasException())
            {
                goto rulemethodEx;
            }


             this->matchToken(8, &FOLLOW_8_in_method101);
            if  (this->hasException())
            {
                goto rulemethodEx;
            }


            {
                m_method_stack.peek().name =(ID1->getText());
            }


            this->followPush(FOLLOW_body_in_method105);
            body();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemethodEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemethodEx; /* Prevent compiler warnings */
    rulemethodEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    m_method_stack.pop(); 

    return ;
}
/* $ANTLR end method */

/**
 * $ANTLR start body
 * ./ASPCore2_0.g:60:1: body : '{' ( bstat )* '}' ;
 */
void
ASPCore2_0Parser::body()
{
        ASPCore2_0ParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // ./ASPCore2_0.g:61:5: ( '{' ( bstat )* '}' )
        // ./ASPCore2_0.g:61:9: '{' ( bstat )* '}'
        {
             this->matchToken(14, &FOLLOW_14_in_body125);
            if  (this->hasException())
            {
                goto rulebodyEx;
            }


            // ./ASPCore2_0.g:61:13: ( bstat )*

            for (;;)
            {
                int alt1=2;
                switch ( this->LA(1) )
                {
                case ID:
                case 13:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1)
                {
            	case 1:
            	    // ./ASPCore2_0.g:61:13: bstat
            	    {
            	        this->followPush(FOLLOW_bstat_in_body127);
            	        bstat();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulebodyEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


             this->matchToken(15, &FOLLOW_15_in_body130);
            if  (this->hasException())
            {
                goto rulebodyEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebodyEx; /* Prevent compiler warnings */
    rulebodyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end body */

/**
 * $ANTLR start bstat
 * ./ASPCore2_0.g:66:1: bstat : ( ID '=' expr ';' | method );
 */
void
ASPCore2_0Parser::bstat()
{
        ASPCore2_0ParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  ./ASPCore2_0.g:67:5: ( ID '=' expr ';' | method )

            ANTLR_UINT32 alt2;

            alt2=2;

            switch ( this->LA(1) )
            {
            case ID:
            	{
            		alt2=1;
            	}
                break;
            case 13:
            	{
            		alt2=2;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< ASPCore2_0ParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 2 );
                ex->set_state( 0 );


                goto rulebstatEx;

            }

            switch (alt2)
            {
        	case 1:
        	    // ./ASPCore2_0.g:67:9: ID '=' expr ';'
        	    {
        	         this->matchToken(ID, &FOLLOW_ID_in_bstat151);
        	        if  (this->hasException())
        	        {
        	            goto rulebstatEx;
        	        }


        	         this->matchToken(12, &FOLLOW_12_in_bstat153);
        	        if  (this->hasException())
        	        {
        	            goto rulebstatEx;
        	        }


        	        this->followPush(FOLLOW_expr_in_bstat155);
        	        expr();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulebstatEx;
        	        }


        	         this->matchToken(11, &FOLLOW_11_in_bstat157);
        	        if  (this->hasException())
        	        {
        	            goto rulebstatEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ./ASPCore2_0.g:68:9: method
        	    {
        	        this->followPush(FOLLOW_method_in_bstat167);
        	        method();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulebstatEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulebstatEx; /* Prevent compiler warnings */
    rulebstatEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end bstat */

/**
 * $ANTLR start expr
 * ./ASPCore2_0.g:71:1: expr : mul ( '+' mul )* ;
 */
void
ASPCore2_0Parser::expr()
{
        ASPCore2_0ParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // ./ASPCore2_0.g:71:5: ( mul ( '+' mul )* )
        // ./ASPCore2_0.g:71:9: mul ( '+' mul )*
        {
            this->followPush(FOLLOW_mul_in_expr182);
            mul();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexprEx;
            }


            // ./ASPCore2_0.g:71:13: ( '+' mul )*

            for (;;)
            {
                int alt3=2;
                switch ( this->LA(1) )
                {
                case 10:
                	{
                		alt3=1;
                	}
                    break;

                }

                switch (alt3)
                {
            	case 1:
            	    // ./ASPCore2_0.g:71:14: '+' mul
            	    {
            	         this->matchToken(10, &FOLLOW_10_in_expr185);
            	        if  (this->hasException())
            	        {
            	            goto ruleexprEx;
            	        }


            	        this->followPush(FOLLOW_mul_in_expr187);
            	        mul();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexprEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop3;	/* break out of the loop */
            	    break;
                }
            }
            loop3: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexprEx; /* Prevent compiler warnings */
    ruleexprEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end expr */

/**
 * $ANTLR start mul
 * ./ASPCore2_0.g:74:1: mul : atom ( '*' atom )* ;
 */
void
ASPCore2_0Parser::mul()
{
        ASPCore2_0ParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // ./ASPCore2_0.g:74:5: ( atom ( '*' atom )* )
        // ./ASPCore2_0.g:74:9: atom ( '*' atom )*
        {
            this->followPush(FOLLOW_atom_in_mul205);
            atom();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemulEx;
            }


            // ./ASPCore2_0.g:74:14: ( '*' atom )*

            for (;;)
            {
                int alt4=2;
                switch ( this->LA(1) )
                {
                case 9:
                	{
                		alt4=1;
                	}
                    break;

                }

                switch (alt4)
                {
            	case 1:
            	    // ./ASPCore2_0.g:74:15: '*' atom
            	    {
            	         this->matchToken(9, &FOLLOW_9_in_mul208);
            	        if  (this->hasException())
            	        {
            	            goto rulemulEx;
            	        }


            	        this->followPush(FOLLOW_atom_in_mul210);
            	        atom();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop4;	/* break out of the loop */
            	    break;
                }
            }
            loop4: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemulEx; /* Prevent compiler warnings */
    rulemulEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end mul */

/**
 * $ANTLR start atom
 * ./ASPCore2_0.g:82:1: atom : ( ID | INT );
 */
void
ASPCore2_0Parser::atom()
{
        ASPCore2_0ParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // ./ASPCore2_0.g:83:5: ( ID | INT )
        // ./ASPCore2_0.g:
        {
            if ( ((this->LA(1) >= ID) && (this->LA(1) <= INT)) )
            {
                this->consume();
                this->set_perror_recovery(false);
            }
            else
            {
                new ANTLR_Exception< ASPCore2_0ParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto ruleatomEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleatomEx; /* Prevent compiler warnings */
    ruleatomEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end atom */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

	}


/* End of code
 * =============================================================================
 */
